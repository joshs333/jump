/**
 * @file random.hpp
 * @author Joshua Spisak (jspisak@andrew.cmu.edu)
 * @brief Utilities for interopable random number generation.
 * @date 2023-05-09
 */
#ifndef JUMP_RANDOM_HPP_
#define JUMP_RANDOM_HPP_

// JUMP
#include <jump/device_interface.hpp>

// STD
#include <chrono>
#include <cmath>
#include <random>

namespace jump {

//! The underlying type to use for seeds
using seed_t = uint64_t;

/**
 * @brief generate a random seed using std::random_device
 * @return a seed generated by a random device
 */
seed_t random_seed() {
    std::random_device rd;
    return seed_t(rd()) << 31 | seed_t(rd());
}

/**
 * @brief generate a seed using the system clock
 * @return a seed generated from the current time (sampled at the millisecond level)
 */
seed_t time_seed() {
    auto t = std::chrono::system_clock::now().time_since_epoch();
    return static_cast<seed_t>(std::chrono::duration_cast<std::chrono::milliseconds>(t).count());
}

/**
 * @brief salt seed with some offset
 * @param seed the seed to salt
 * @param offset the offset to add in the salting
 * @return a salted seed
 * @note can be used in tandem with random_seed() or time_seed()
 */
JUMP_INTEROPABLE
seed_t salt_seed(seed_t seed, seed_t offset) {
    // ^ with some random non-zero sequence
    auto salted_offset = static_cast<seed_t>(seed ^ 0xa73a178dUL) | static_cast<uint64_t>((seed >> 32) ^ 0xb4f25e9dUL);
    // mix up bit with multiplication against an arbitrary odd number
    return (offset + salted_offset) * 3477983549775753007ULL;
}

/**
 * @brief pseudo-random-number-generator that can use
 *  the splitmix, xorshift, and pcg algorithms to generate
 *  32-bit random numbers.
 *
 *  Big thanks to Arvid Gerstmann's [blog post](https://arvid.io/2018/07/02/better-cxx-prng/),
 *  which was helpful for this implementation.
 */
class prng {
public:
    //! The verious rng algorithms can can be used
    enum struct rng_t : uint8_t {
        //! The splitmix algorithm [url](https://xoshiro.di.unimi.it/splitmix64.c)
        SPLITMIX = 0,
        //! The xorshift algorithm
        XORSHIFT = 1,
        //! The PCG algorithm [url](https://www.pcg-random.org/download.html)
        PCG = 2
    };

    /**
     * @brief create a new prng, with a given seed
     * @param seed the seed to use
     * @param alg the algorithm to use
     * @note this is normal to construction with prng(const rng_t&), then
     *  calling the seed(const seed_t&) method.
     */
    JUMP_INTEROPABLE
    prng(const seed_t& seed, const rng_t& alg = rng_t::SPLITMIX):
        alg_(alg),
        seed_(1),
        inc_(1)
    {
        this->seed(seed);
    }

    /**
     * @brief create a new prng
     * @param alg the algorithm to use
     */
    JUMP_INTEROPABLE
    prng(const rng_t& alg = rng_t::XORSHIFT):
        alg_(alg),
        seed_(1),
        inc_(1)
    {}

    /**
     * @brief set a seed for the rng to use
     * @param new_seed the new seed to use
     */
    JUMP_INTEROPABLE
    void seed(const seed_t& new_seed) {
        if(alg_ == rng_t::PCG) {
            seed_t s0 = new_seed * 2882398392818937482ull;
            seed_t s1 = new_seed * 2882398392818937482ull;
            seed_ = 0;
            inc_ = (s1 << 1) | 1;
            (void)operator()();
            seed_ += s0;
            (void)operator()();
        } else {
            seed_ = new_seed;
        }
    }

    /**
     * @brief Operator used to generate a psuedo-random number.
     * @return A (pseudo)-random uint32_t value (uniform dist. between 0 and max uint32_t) 
     */
    JUMP_INTEROPABLE
    uint32_t operator()() {
        if(alg_ == rng_t::SPLITMIX) {
            uint64_t z = (seed_ += UINT64_C(0x9E3779B97F4A7C15));
            z = (z ^ (z >> 30)) * UINT64_C(0xBF58476D1CE4E5B9);
            z = (z ^ (z >> 27)) * UINT64_C(0x94D049BB133111EB);
            return uint32_t((z ^ (z >> 31)) >> 31);
        } else if(alg_ == rng_t::XORSHIFT) {
            uint64_t result = seed_ * 0xd989bcacc137dcd5ull;
            seed_ ^= seed_ >> 11;
            seed_ ^= seed_ << 31;
            seed_ ^= seed_ >> 18;
            return uint32_t(result >> 32ull);
        } else {
            uint64_t oldstate = seed_;
            seed_ = oldstate * 6364136223846793005ULL + inc_;
            uint32_t xorshifted = uint32_t(((oldstate >> 18u) ^ oldstate) >> 27u);
            int rot = oldstate >> 59u;
            return (xorshifted >> rot) | (xorshifted << ((-rot) & 31));
        }
    }

    //! Result type to allow this rng to be used with std distributions
    using result_type = uint32_t;
    //! min value to allow this rng to be used with std distributions
    static constexpr result_type (min)() { return 0; }
    //! max value to allow this rng to be used with std distributions
    static constexpr result_type (max)() { return UINT32_MAX; }
    //! == operator to allow this rng to be used with std distributions
    friend bool operator==(prng const &, prng const &);
    //! != operator to allow this rng to be used with std distributions
    friend bool operator!=(prng const &, prng const &);

private:
    //! The algorithm to use
    rng_t alg_;
    //! The current seed (used for state for PCG)
    seed_t seed_;
    //! Increment state for PCG
    seed_t inc_;

}; /* class prng */

//! Comparison operator for prng - NOT REAL! (TODO(jspisak): make it real)
bool operator==(prng const &lhs, prng const &rhs)
{
    return lhs.seed_ == rhs.seed_;
}

//! Comparison operator for prng - NOT REAL! (TODO(jspisak): make it real)
bool operator!=(prng const &lhs, prng const &rhs)
{
    return lhs.seed_ != rhs.seed_;
}

/**
 * @brief Samples from a random number generator to make a normal distribution
 * @tparam precision_t the precision to use for generating numbers
 */
template<typename precision_t = double >
class normal_distribution {
public:
    /**
     * @brief create a normal distribution
     * @param mean the mean of this normal distribution
     * @param std_dev the std deviation of this normal distribution
     */
    JUMP_INTEROPABLE
    normal_distribution(
        const precision_t& mean = 0.0,
        const precision_t& std_dev = 1.0
    ):
        mean_(mean),
        std_dev_(std_dev),
        has_box_muller_extra_(false)
    {
    }

    /**
     * @brief sample a number from this normal distribution
     * @tparam GeneratorT the type of base rng to use
     * @param rng the base rng to use
     * @return a float number samples from this normal distribution
     */
    template<typename GeneratorT>
    JUMP_INTEROPABLE
    precision_t operator()(GeneratorT& rng) {
        #ifndef JUMP_DISABLE_BOX_MULLER_EXTRA
            if(has_box_muller_extra_) {
                has_box_muller_extra_ = false;
                return box_muller_extra_;
            }
        #endif
        // box-muller projection
        constexpr precision_t inv_2pow32 = precision_t(1) / precision_t(uint64_t(1) << 32);
        constexpr precision_t two_pi_inv_2pow32 = 2 * 3.1415925358979 / precision_t(uint64_t(1) << 32);

        auto x = rng();
        auto y = rng();
    
        precision_t u = x * inv_2pow32 + inv_2pow32 / 2.0;
        precision_t v = y * two_pi_inv_2pow32 + inv_2pow32 / 2.0;

        precision_t s, r1, r2;
        #if JUMP_ON_DEVICE
            #if __CUDA_ARCH__ > 0
                if constexpr(std::is_same<precision_t, float>::value) {
                    s = sqrtf(-2.0f * logf(u));
                    __sincosf(v, &r1, &r2);
                } else {
                    s = sqrt(-2.0f * log(u));
                    r1 = sin(v);
                    r2 = cos(v);
                }
            #else
                if constexpr(std::is_same<precision_t, float>::value) {
                    s = sqrtf(-2.0f * logf(u));
                    r1 = sinf(v);
                    r2 = cosf(v);
                } else {
                    s = sqrt(-2.0f * log(u));
                    r1 = sin(v);
                    r2 = cos(v);
                }
            #endif
        #else
            s = std::sqrt(-2.0f * std::log(u));
            r1 = std::sin(v);
            r2 = std::cos(v);
        #endif
        r1 = r1 * s * std_dev_ + mean_;
        r2 = r2 * s * std_dev_ + mean_;
        #ifndef JUMP_DISABLE_BOX_MULLER_EXTRA
            has_box_muller_extra_ = true;
            box_muller_extra_ = r2;
        #endif
        return static_cast<precision_t>(r1);
    }

private:
    //! The mean of this distribution
    precision_t mean_;
    //! The std deviation of this distrution
    precision_t std_dev_;

    //! Whether we have an extra box-muller value to use
    bool has_box_muller_extra_;
    //! The extra box-muller value to use
    precision_t box_muller_extra_;

}; /* class normal_distribution */

/**
 * @brief Samples from the log-normal distribution.
 * @tparam precision_t The level of precision to use.
 * @note An explanation of this distrubition can be found [here](https://towardsdatascience.com/log-normal-distribution-a-simple-explanation-7605864fb67c).
 */
template<typename precision_t = double >
class log_normal_distribution {
public:
    /**
     * @brief Construct a new log normal distribution object
     * @param location the location of this distribution
     * @param scale the scale of this distribution
     */
    JUMP_INTEROPABLE
    log_normal_distribution(
        const precision_t& location,
        const precision_t& scale
    ):
        norm_(location, scale)
    {
    }

    /**
     * @brief sample a number from this log-normal distribution
     * @tparam GeneratorT the type of base rng to use
     * @param rng the base rng to use
     * @return a float number samples from this log-normal distribution
     */
    template<typename GeneratorT>
    JUMP_INTEROPABLE
    precision_t operator()(GeneratorT& rng) {
        return exp(norm_(rng));
    }

private:
    //! A normal distribution we can sample from to get a log normal distribution
    normal_distribution<precision_t> norm_;

}; /* class log_normal_distribution */

/**
 * @brief samples from a uniform distribution
 * @tparam precision_t the level of precision to use
 */
template<typename precision_t = double >
class uniform_distribution {
public:

    /**
     * @brief create a new uniform random distribution
     * @param min the minimum value to sample
     * @param max the maximum value to sample
     * @note I implemented this quickly... pretty sure this is inclusive of both bounds?
     *  but also it's for a real number so the odds of getting them dead on is low
     */
    uniform_distribution(
        const precision_t& min,
        const precision_t& max
    ):
        min_(min),
        max_(max)
    {}

    /**
     * @brief sample a number from this uniform distribution
     * @tparam GeneratorT the type of base rng to use
     * @param rng the base rng to use
     * @return a float number samples from this uniform distribution
     */
    template<typename GeneratorT>
    JUMP_INTEROPABLE
    precision_t operator()(GeneratorT& rng) {
        auto n = rng();
        constexpr auto width = std::numeric_limits<typename GeneratorT::result_type>::max() - std::numeric_limits<typename GeneratorT::result_type>::min();
        auto offset = n - std::numeric_limits<typename GeneratorT::result_type>::min();
        
        return min_ + (max_ - min_) * static_cast<precision_t>(offset) / static_cast<precision_t>(width);

    }

private:
    //! The minumum value to sample
    precision_t min_;
    //! The maximum value to sample
    precision_t max_;

}; /* class uniform_distribution */

} /* namespace jump */

#endif /* JUMP_RANDOM_HPP_ */
